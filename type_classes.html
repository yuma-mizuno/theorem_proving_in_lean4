<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>型クラス - Theorem Proving in Lean 4</title>


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme && theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar && sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title_page.html">Theorem Proving in Lean 4</a></li><li class="chapter-item expanded "><a href="introduction.html"><strong aria-hidden="true">1.</strong> イントロダクション</a></li><li class="chapter-item expanded "><a href="dependent_type_theory.html"><strong aria-hidden="true">2.</strong> 依存型理論</a></li><li class="chapter-item expanded "><a href="propositions_and_proofs.html"><strong aria-hidden="true">3.</strong> 命題と証明</a></li><li class="chapter-item expanded "><a href="quantifiers_and_equality.html"><strong aria-hidden="true">4.</strong> 量化と等号</a></li><li class="chapter-item expanded "><a href="tactics.html"><strong aria-hidden="true">5.</strong> 戦術</a></li><li class="chapter-item expanded "><a href="interacting_with_lean.html"><strong aria-hidden="true">6.</strong> Leanと対話する</a></li><li class="chapter-item expanded "><a href="inductive_types.html"><strong aria-hidden="true">7.</strong> 帰納型</a></li><li class="chapter-item expanded "><a href="induction_and_recursion.html"><strong aria-hidden="true">8.</strong> 帰納と再帰</a></li><li class="chapter-item expanded "><a href="structures_and_records.html"><strong aria-hidden="true">9.</strong> StructuresとRecords</a></li><li class="chapter-item expanded "><a href="type_classes.html" class="active"><strong aria-hidden="true">10.</strong> 型クラス</a></li><li class="chapter-item expanded "><a href="conv.html"><strong aria-hidden="true">11.</strong> Conversion戦術モード</a></li><li class="chapter-item expanded "><a href="axioms_and_computation.html"><strong aria-hidden="true">12.</strong> 公理と計算</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Theorem Proving in Lean 4</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/leanprover/theorem_proving_in_lean4" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="type-classes"><a class="header" href="#type-classes">Type Classes</a></h1>
<p>Type classes were introduced as a principled way of enabling
ad-hoc polymorphism in functional programming languages. We first observe that it
would be easy to implement an ad-hoc polymorphic function (such as addition) if the
function simply took the type-specific implementation of addition as an argument
and then called that implementation on the remaining arguments. For example,
suppose we declare a structure in Lean to hold implementations of addition.</p>
<pre><code class="language-lean"><span class="boring">namespace Ex
</span>structure Add (a : Type) where
  add : a → a → a

#check @Add.add
-- Add.add : {a : Type} → Add a → a → a → a
<span class="boring">end Ex
</span></code></pre>
<p>In the above Lean code, the field <code>add</code> has type
<code>Add.add : {a : Type} → Add a → a → a → a</code>
where the curly braces around the type <code>a</code> mean that it is an implicit argument.
We could implement <code>double</code> by:</p>
<pre><code class="language-lean"><span class="boring">namespace Ex
</span><span class="boring">structure Add (a : Type) where
</span><span class="boring"> add : a → a → a
</span>def double (s : Add a) (x : a) : a :=
  s.add x x

#eval double { add := Nat.add } 10
-- 20

#eval double { add := Nat.mul } 10
-- 100

#eval double { add := Int.add } 10
-- 20
<span class="boring">end Ex
</span></code></pre>
<p>Note that you can double a natural number <code>n</code> by <code>double { add := Nat.add } n</code>.
Of course, it would be highly cumbersome for users to manually pass the
implementations around in this way.
Indeed, it would defeat most of the potential benefits of ad-hoc
polymorphism.</p>
<p>The main idea behind type classes is to make arguments such as <code>Add a</code> implicit,
and to use a database of user-defined instances to synthesize the desired instances
automatically through a process known as typeclass resolution. In Lean, by changing
<code>structure</code> to <code>class</code> in the example above, the type of <code>Add.add</code> becomes:</p>
<pre><code class="language-lean"><span class="boring">namespace Ex
</span>class Add (a : Type) where
  add : a → a → a

#check @Add.add
-- Add.add : {a : Type} → [self : Add a] → a → a → a
<span class="boring">end Ex
</span></code></pre>
<p>where the square brackets indicate that the argument of type <code>Add a</code> is <em>instance implicit</em>,
i.e. that it should be synthesized using typeclass resolution. This version of
<code>add</code> is the Lean analogue of the Haskell term <code>add :: Add a =&gt; a -&gt; a -&gt; a</code>.
Similarly, we can register instances by:</p>
<pre><code class="language-lean"><span class="boring">namespace Ex
</span><span class="boring">class Add (a : Type) where
</span><span class="boring"> add : a → a → a
</span>instance : Add Nat where
  add := Nat.add

instance : Add Int where
  add := Int.add

instance : Add Float where
  add := Float.add
<span class="boring">end Ex
</span></code></pre>
<p>Then for <code>n : Nat</code> and <code>m : Nat</code>, the term <code>Add.add n m</code> triggers typeclass resolution with
the goal of <code>Add Nat</code>, and typeclass resolution will synthesize the instance for <code>Nat</code> above.
We can now reimplement <code>double</code> using an instance implicit by:</p>
<pre><code class="language-lean"><span class="boring">namespace Ex
</span><span class="boring">class Add (a : Type) where
</span><span class="boring">  add : a → a → a
</span><span class="boring">instance : Add Nat where
</span><span class="boring"> add := Nat.add
</span><span class="boring">instance : Add Int where
</span><span class="boring"> add := Int.add
</span><span class="boring">instance : Add Float where
</span><span class="boring"> add := Float.add
</span>def double [Add a] (x : a) : a :=
  Add.add x x

#check @double
-- @double : {a : Type} → [inst : Add a] → a → a

#eval double 10
-- 20

#eval double (10 : Int)
-- 100

#eval double (7 : Float)
-- 14.000000

#eval double (239.0 + 2)
-- 482.000000

<span class="boring">end Ex
</span></code></pre>
<p>In general, instances may depend on other instances in complicated ways. For example,
you can declare an (anonymous) instance stating that if <code>a</code> has addition, then <code>Array a</code>
has addition:</p>
<pre><code class="language-lean">instance [Add a] : Add (Array a) where
  add x y := Array.zipWith x y (· + ·)

#eval Add.add #[1, 2] #[3, 4]
-- #[4, 6]

#eval #[1, 2] + #[3, 4]
-- #[4, 6]
</code></pre>
<p>Note that <code>(· + ·)</code> is notation for <code>fun x y =&gt; x + y</code> in Lean.</p>
<p>The example above demonstrates how type classes are used to overload notation.
Now, we explore another application. We often need an arbitrary element of a given type.
Recall that types may not have any elements in Lean.
It often happens that we would like a definition to return an arbitrary element in a &quot;corner case.&quot;
For example, we may like the expression <code>head xs</code> to be of type <code>a</code> when <code>xs</code> is of type <code>List a</code>.
Similarly, many theorems hold under the additional assumption that a type is not empty.
For example, if <code>a</code> is a type, <code>exists x : a, x = x</code> is true only if <code>a</code> is not empty.
The standard library defines a type class <code>Inhabited</code> to enable type class inference to infer a
&quot;default&quot; element of an inhabited type.
Let us start with the first step of the program above, declaring an appropriate class:</p>
<pre><code class="language-lean"><span class="boring">namespace Ex
</span>class Inhabited (a : Type u) where
  default : a

#check @Inhabited.default
-- Inhabited.default : {a : Type u} → [self : Inhabited a] → a
<span class="boring">end Ex
</span></code></pre>
<p>Note <code>Inhabited.default</code> doesn't have any explicit arguments.</p>
<p>An element of the class <code>Inhabited a</code> is simply an expression of the form <code>Inhabited.mk x</code>, for some element <code>x : a</code>.
The projection <code>Inhabited.default</code> will allow us to &quot;extract&quot; such an element of <code>a</code> from an element of <code>Inhabited a</code>.
Now we populate the class with some instances:</p>
<pre><code class="language-lean"><span class="boring">namespace Ex
</span><span class="boring">class Inhabited (a : Type _) where
</span><span class="boring"> default : a
</span>instance : Inhabited Bool where
  default := true

instance : Inhabited Nat where
  default := 0

instance : Inhabited Unit where
  default := ()

instance : Inhabited Prop where
  default := True

#eval (Inhabited.default : Nat)
-- 0

#eval (Inhabited.default : Bool)
-- true
<span class="boring">end Ex
</span></code></pre>
<p>You can use the command <code>export</code> to create the alias <code>default</code> for <code>Inhabited.default</code></p>
<pre><code class="language-lean"><span class="boring">namespace Ex
</span><span class="boring">class Inhabited (a : Type _) where
</span><span class="boring"> default : a
</span><span class="boring">instance : Inhabited Bool where
</span><span class="boring"> default := true
</span><span class="boring">instance : Inhabited Nat where
</span><span class="boring"> default := 0
</span><span class="boring">instance : Inhabited Unit where
</span><span class="boring"> default := ()
</span><span class="boring">instance : Inhabited Prop where
</span><span class="boring"> default := True
</span>export Inhabited (default)

#eval (default : Nat)
-- 0

#eval (default : Bool)
-- true
<span class="boring">end Ex
</span></code></pre>
<h2 id="chaining-instances"><a class="header" href="#chaining-instances">Chaining Instances</a></h2>
<p>If that were the extent of type class inference, it would not be all that impressive;
it would be simply a mechanism of storing a list of instances for the elaborator to find in a lookup table.
What makes type class inference powerful is that one can <em>chain</em> instances. That is,
an instance declaration can in turn depend on an implicit instance of a type class.
This causes class inference to chain through instances recursively, backtracking when necessary, in a Prolog-like search.</p>
<p>For example, the following definition shows that if two types <code>a</code> and <code>b</code> are inhabited, then so is their product:</p>
<pre><code class="language-lean">instance [Inhabited a] [Inhabited b] : Inhabited (a × b) where
  default := (default, default)
</code></pre>
<p>With this added to the earlier instance declarations, type class instance can infer, for example, a default element of <code>Nat × Bool</code>:</p>
<pre><code class="language-lean"><span class="boring">namespace Ex
</span><span class="boring">class Inhabited (a : Type u) where
</span><span class="boring"> default : a
</span><span class="boring">instance : Inhabited Bool where
</span><span class="boring"> default := true
</span><span class="boring">instance : Inhabited Nat where
</span><span class="boring"> default := 0
</span><span class="boring">opaque default [Inhabited a] : a :=
</span><span class="boring"> Inhabited.default
</span>instance [Inhabited a] [Inhabited b] : Inhabited (a × b) where
  default := (default, default)

#eval (default : Nat × Bool)
-- (0, true)
<span class="boring">end Ex
</span></code></pre>
<p>Similarly, we can inhabit type function with suitable constant functions:</p>
<pre><code class="language-lean">instance [Inhabited b] : Inhabited (a → b) where
  default := fun _ =&gt; default
</code></pre>
<p>As an exercise, try defining default instances for other types, such as <code>List</code> and <code>Sum</code> types.</p>
<p>The Lean standard library contains the definition <code>inferInstance</code>. It has type <code>{α : Sort u} → [i : α] → α</code>,
and is useful for triggering the type class resolution procedure when the expected type is an instance.</p>
<pre><code class="language-lean">#check (inferInstance : Inhabited Nat) -- Inhabited Nat

def foo : Inhabited (Nat × Nat) :=
  inferInstance

theorem ex : foo.default = (default, default) :=
  rfl
</code></pre>
<p>You can use the command <code>#print</code> to inspect how simple <code>inferInstance</code> is.</p>
<pre><code class="language-lean">#print inferInstance
</code></pre>
<h2 id="tostring"><a class="header" href="#tostring">ToString</a></h2>
<p>The polymorphic method <code>toString</code> has type <code>{α : Type u} → [ToString α] → α → String</code>. You implement the instance
for your own types and use chaining to convert complex values into strings. Lean comes with <code>ToString</code> instances
for most builtin types.</p>
<pre><code class="language-lean">structure Person where
  name : String
  age  : Nat

instance : ToString Person where
  toString p := p.name ++ &quot;@&quot; ++ toString p.age

#eval toString { name := &quot;Leo&quot;, age := 542 : Person }
#eval toString ({ name := &quot;Daniel&quot;, age := 18 : Person }, &quot;hello&quot;)
</code></pre>
<h2 id="numerals"><a class="header" href="#numerals">Numerals</a></h2>
<p>Numerals are polymorphic in Lean. You can use a numeral (e.g., <code>2</code>) to denote an element of any type that implements
the type class <code>OfNat</code>.</p>
<pre><code class="language-lean">structure Rational where
  num : Int
  den : Nat
  inv : den ≠ 0

instance : OfNat Rational n where
  ofNat := { num := n, den := 1, inv := by decide }

instance : ToString Rational where
  toString r := s!&quot;{r.num}/{r.den}&quot;

#eval (2 : Rational) -- 2/1

#check (2 : Rational) -- Rational
#check (2 : Nat)      -- Nat
</code></pre>
<p>Lean elaborates the terms <code>(2 : Nat)</code> and <code>(2 : Rational)</code> as
<code>OfNat.ofNat Nat 2 (instOfNatNat 2)</code> and
<code>OfNat.ofNat Rational 2 (instOfNatRational 2)</code> respectively.
We say the numerals <code>2</code> occurring in the elaborated terms are <em>raw</em> natural numbers.
You can input the raw natural number <code>2</code> using the macro <code>nat_lit 2</code>.</p>
<pre><code class="language-lean">#check nat_lit 2  -- Nat
</code></pre>
<p>Raw natural numbers are <em>not</em> polymorphic.</p>
<p>The <code>OfNat</code> instance is parametric on the numeral. So, you can define instances for particular numerals.
The second argument is often a variable as in the example above, or a <em>raw</em> natural number.</p>
<pre><code class="language-lean">class Monoid (α : Type u) where
  unit : α
  op   : α → α → α

instance [s : Monoid α] : OfNat α (nat_lit 1) where
  ofNat := s.unit

def getUnit [Monoid α] : α :=
  1
</code></pre>
<h2 id="output-parameters"><a class="header" href="#output-parameters">Output Parameters</a></h2>
<p>By default, Lean only tries to synthesize an instance <code>Inhabited T</code> when the term <code>T</code> is known and does not
contain missing parts. The following command produces the error
&quot;typeclass instance problem is stuck, it is often due to metavariables <code>?m.7</code>&quot; because the type has a missing part (i.e., the <code>_</code>).</p>
<pre><code class="language-lean">#check_failure (inferInstance : Inhabited (Nat × _))
</code></pre>
<p>You can view the parameter of the type class <code>Inhabited</code> as an <em>input</em> value for the type class synthesizer.
When a type class has multiple parameters, you can mark some of them as output parameters.
Lean will start type class synthesizer even when these parameters have missing parts.
In the following example, we use output parameters to define a <em>heterogeneous</em> polymorphic
multiplication.</p>
<pre><code class="language-lean"><span class="boring">namespace Ex
</span>class HMul (α : Type u) (β : Type v) (γ : outParam (Type w)) where
  hMul : α → β → γ

export HMul (hMul)

instance : HMul Nat Nat Nat where
  hMul := Nat.mul

instance : HMul Nat (Array Nat) (Array Nat) where
  hMul a bs := bs.map (fun b =&gt; hMul a b)

#eval hMul 4 3           -- 12
#eval hMul 4 #[2, 3, 4]  -- #[8, 12, 16]
<span class="boring">end Ex
</span></code></pre>
<p>The parameters <code>α</code> and <code>β</code> are considered input parameters and <code>γ</code> an output one.
Given an application <code>hMul a b</code>, after the types of <code>a</code> and <code>b</code> are known, the type class
synthesizer is invoked, and the resulting type is obtained from the output parameter <code>γ</code>.
In the example above, we defined two instances. The first one is the homogeneous
multiplication for natural numbers. The second is the scalar multiplication for arrays.
Note that you chain instances and generalize the second instance.</p>
<pre><code class="language-lean"><span class="boring">namespace Ex
</span>class HMul (α : Type u) (β : Type v) (γ : outParam (Type w)) where
  hMul : α → β → γ

export HMul (hMul)

instance : HMul Nat Nat Nat where
  hMul := Nat.mul

instance : HMul Int Int Int where
  hMul := Int.mul

instance [HMul α β γ] : HMul α (Array β) (Array γ) where
  hMul a bs := bs.map (fun b =&gt; hMul a b)

#eval hMul 4 3                    -- 12
#eval hMul 4 #[2, 3, 4]           -- #[8, 12, 16]
#eval hMul (-2) #[3, -1, 4]       -- #[-6, 2, -8]
#eval hMul 2 #[#[2, 3], #[0, 4]]  -- #[#[4, 6], #[0, 8]]
<span class="boring">end Ex
</span></code></pre>
<p>You can use our new scalar array multiplication instance on arrays of type <code>Array β</code>
with a scalar of type <code>α</code> whenever you have an instance <code>HMul α β γ</code>.
In the last <code>#eval</code>, note that the instance was used twice on an array of arrays.</p>
<h2 id="default-instances"><a class="header" href="#default-instances">Default Instances</a></h2>
<p>In the class <code>HMul</code>, the parameters <code>α</code> and <code>β</code> are treated as input values.
Thus, type class synthesis only starts after these two types are known. This may often
be too restrictive.</p>
<pre><code class="language-lean"><span class="boring">namespace Ex
</span>class HMul (α : Type u) (β : Type v) (γ : outParam (Type w)) where
  hMul : α → β → γ

export HMul (hMul)

instance : HMul Int Int Int where
  hMul := Int.mul

def xs : List Int := [1, 2, 3]

-- Error &quot;typeclass instance problem is stuck, it is often due to metavariables HMul ?m.89 ?m.90 ?m.91&quot;
#check_failure fun y =&gt; xs.map (fun x =&gt; hMul x y)
<span class="boring">end Ex
</span></code></pre>
<p>The instance <code>HMul</code> is not synthesized by Lean because the type of <code>y</code> has not been provided.
However, it is natural to assume that the type of <code>y</code> and <code>x</code> should be the same in
this kind of situation. We can achieve exactly that using <em>default instances</em>.</p>
<pre><code class="language-lean"><span class="boring">namespace Ex
</span>class HMul (α : Type u) (β : Type v) (γ : outParam (Type w)) where
  hMul : α → β → γ

export HMul (hMul)

@[default_instance]
instance : HMul Int Int Int where
  hMul := Int.mul

def xs : List Int := [1, 2, 3]

#check fun y =&gt; xs.map (fun x =&gt; hMul x y)  -- Int → List Int
<span class="boring">end Ex
</span></code></pre>
<p>By tagging the instance above with the attribute <code>default_instance</code>, we are instructing Lean
to use this instance on pending type class synthesis problems.
The actual Lean implementation defines homogeneous and heterogeneous classes for arithmetical operators.
Moreover, <code>a+b</code>, <code>a*b</code>, <code>a-b</code>, <code>a/b</code>, and <code>a%b</code> are notations for the heterogeneous versions.
The instance <code>OfNat Nat n</code> is the default instance (with priority 100) for the <code>OfNat</code> class. This is why the numeral
<code>2</code> has type <code>Nat</code> when the expected type is not known. You can define default instances with higher
priority to override the builtin ones.</p>
<pre><code class="language-lean">structure Rational where
  num : Int
  den : Nat
  inv : den ≠ 0

@[default_instance 200]
instance : OfNat Rational n where
  ofNat := { num := n, den := 1, inv := by decide }

instance : ToString Rational where
  toString r := s!&quot;{r.num}/{r.den}&quot;

#check 2 -- Rational
</code></pre>
<p>Priorities are also useful to control the interaction between different default instances.
For example, suppose <code>xs</code> has type <code>List α</code>. When elaborating <code>xs.map (fun x =&gt; 2 * x)</code>, we want the homogeneous instance for multiplication
to have higher priority than the default instance for <code>OfNat</code>. This is particularly important when we have implemented only the instance
<code>HMul α α α</code>, and did not implement <code>HMul Nat α α</code>.
Now, we reveal how the notation <code>a*b</code> is defined in Lean.</p>
<pre><code class="language-lean"><span class="boring">namespace Ex
</span>class OfNat (α : Type u) (n : Nat) where
  ofNat : α

@[default_instance]
instance (n : Nat) : OfNat Nat n where
  ofNat := n

class HMul (α : Type u) (β : Type v) (γ : outParam (Type w)) where
  hMul : α → β → γ

class Mul (α : Type u) where
  mul : α → α → α

@[default_instance 10]
instance [Mul α] : HMul α α α where
  hMul a b := Mul.mul a b

infixl:70 &quot; * &quot; =&gt; HMul.hMul
<span class="boring">end Ex
</span></code></pre>
<p>The <code>Mul</code> class is convenient for types that only implement the homogeneous multiplication.</p>
<h2 id="local-instances"><a class="header" href="#local-instances">Local Instances</a></h2>
<p>Type classes are implemented using attributes in Lean. Thus, you can
use the <code>local</code> modifier to indicate that they only have effect until
the current <code>section</code> or <code>namespace</code> is closed, or until the end
of the current file.</p>
<pre><code class="language-lean">structure Point where
  x : Nat
  y : Nat

section

local instance : Add Point where
  add a b := { x := a.x + b.x, y := a.y + b.y }

def double (p : Point) :=
  p + p

end -- instance `Add Point` is not active anymore

-- def triple (p : Point) :=
--  p + p + p  -- Error: failed to synthesize instance
</code></pre>
<p>You can also temporarily disable an instance using the <code>attribute</code> command
until the current <code>section</code> or <code>namespace</code> is closed, or until the end
of the current file.</p>
<pre><code class="language-lean">structure Point where
  x : Nat
  y : Nat

instance addPoint : Add Point where
  add a b := { x := a.x + b.x, y := a.y + b.y }

def double (p : Point) :=
  p + p

attribute [-instance] addPoint

-- def triple (p : Point) :=
--  p + p + p  -- Error: failed to synthesize instance
</code></pre>
<p>We recommend you only use this command to diagnose problems.</p>
<h2 id="scoped-instances"><a class="header" href="#scoped-instances">Scoped Instances</a></h2>
<p>You can also declare scoped instances in namespaces. This kind of instance is
only active when you are inside of the namespace or open the namespace.</p>
<pre><code class="language-lean">structure Point where
  x : Nat
  y : Nat

namespace Point

scoped instance : Add Point where
  add a b := { x := a.x + b.x, y := a.y + b.y }

def double (p : Point) :=
  p + p

end Point
-- instance `Add Point` is not active anymore

-- #check fun (p : Point) =&gt; p + p + p  -- Error

namespace Point
-- instance `Add Point` is active again
#check fun (p : Point) =&gt; p + p + p

end Point

open Point -- activates instance `Add Point`
#check fun (p : Point) =&gt; p + p + p
</code></pre>
<p>You can use the command <code>open scoped &lt;namespace&gt;</code> to activate scoped attributes but will
not &quot;open&quot; the names from the namespace.</p>
<pre><code class="language-lean">structure Point where
  x : Nat
  y : Nat

namespace Point

scoped instance : Add Point where
  add a b := { x := a.x + b.x, y := a.y + b.y }

def double (p : Point) :=
  p + p

end Point

open scoped Point -- activates instance `Add Point`
#check fun (p : Point) =&gt; p + p + p

-- #check fun (p : Point) =&gt; double p -- Error: unknown identifier 'double'
</code></pre>
<h2 id="decidable-propositions"><a class="header" href="#decidable-propositions">Decidable Propositions</a></h2>
<p>Let us consider another example of a type class defined in the
standard library, namely the type class of <code>Decidable</code>
propositions. Roughly speaking, an element of <code>Prop</code> is said to be
decidable if we can decide whether it is true or false. The
distinction is only useful in constructive mathematics; classically,
every proposition is decidable. But if we use the classical principle,
say, to define a function by cases, that function will not be
computable. Algorithmically speaking, the <code>Decidable</code> type class can
be used to infer a procedure that effectively determines whether or
not the proposition is true. As a result, the type class supports such
computational definitions when they are possible while at the same
time allowing a smooth transition to the use of classical definitions
and classical reasoning.</p>
<p>In the standard library, <code>Decidable</code> is defined formally as follows:</p>
<pre><code class="language-lean"><span class="boring">namespace Hidden
</span>class inductive Decidable (p : Prop) where
  | isFalse (h : ¬p) : Decidable p
  | isTrue  (h : p)  : Decidable p
<span class="boring">end Hidden
</span></code></pre>
<p>Logically speaking, having an element <code>t : Decidable p</code> is stronger
than having an element <code>t : p ∨ ¬p</code>; it enables us to define values
of an arbitrary type depending on the truth value of <code>p</code>. For
example, for the expression <code>if p then a else b</code> to make sense, we
need to know that <code>p</code> is decidable. That expression is syntactic
sugar for <code>ite p a b</code>, where <code>ite</code> is defined as follows:</p>
<pre><code class="language-lean"><span class="boring">namespace Hidden
</span>def ite {α : Sort u} (c : Prop) [h : Decidable c] (t e : α) : α :=
  Decidable.casesOn (motive := fun _ =&gt; α) h (fun _ =&gt; e) (fun _ =&gt; t)
<span class="boring">end Hidden
</span></code></pre>
<p>The standard library also contains a variant of <code>ite</code> called
<code>dite</code>, the dependent if-then-else expression. It is defined as
follows:</p>
<pre><code class="language-lean"><span class="boring">namespace Hidden
</span>def dite {α : Sort u} (c : Prop) [h : Decidable c] (t : c → α) (e : Not c → α) : α :=
  Decidable.casesOn (motive := fun _ =&gt; α) h e t
<span class="boring">end Hidden
</span></code></pre>
<p>That is, in <code>dite c t e</code>, we can assume <code>hc : c</code> in the &quot;then&quot;
branch, and <code>hnc : ¬ c</code> in the &quot;else&quot; branch. To make <code>dite</code> more
convenient to use, Lean allows us to write <code>if h : c then t else e</code>
instead of <code>dite c (λ h : c =&gt; t) (λ h : ¬ c =&gt; e)</code>.</p>
<p>Without classical logic, we cannot prove that every proposition is
decidable. But we can prove that <em>certain</em> propositions are
decidable. For example, we can prove the decidability of basic
operations like equality and comparisons on the natural numbers and
the integers. Moreover, decidability is preserved under propositional
connectives:</p>
<pre><code class="language-lean">#check @instDecidableAnd
  -- {p q : Prop} → [Decidable p] → [Decidable q] → Decidable (And p q)

#check @instDecidableOr
#check @instDecidableNot
</code></pre>
<p>Thus we can carry out definitions by cases on decidable predicates on
the natural numbers:</p>
<pre><code class="language-lean">def step (a b x : Nat) : Nat :=
  if x &lt; a ∨ x &gt; b then 0 else 1

set_option pp.explicit true
#print step
</code></pre>
<p>Turning on implicit arguments shows that the elaborator has inferred
the decidability of the proposition <code>x &lt; a ∨ x &gt; b</code>, simply by
applying appropriate instances.</p>
<p>With the classical axioms, we can prove that every proposition is
decidable. You can import the classical axioms and make the generic
instance of decidability available by opening the <code>Classical</code> namespace.</p>
<pre><code class="language-lean">open Classical
</code></pre>
<p>Thereafter <code>Decidable p</code> has an instance for every <code>p</code>.
Thus all theorems in the library
that rely on decidability assumptions are freely available when you
want to reason classically. In <a href="./axioms_and_computation.html">Chapter Axioms and Computation</a>,
we will see that using the law of the
excluded middle to define functions can prevent them from being used
computationally. Thus, the standard library assigns a low priority to
the <code>propDecidable</code> instance.</p>
<pre><code class="language-lean"><span class="boring">namespace Hidden
</span>open Classical
noncomputable scoped
instance (priority := low) propDecidable (a : Prop) : Decidable a :=
  choice &lt;| match em a with
    | Or.inl h =&gt; ⟨isTrue h⟩
    | Or.inr h =&gt; ⟨isFalse h⟩
<span class="boring">end Hidden
</span></code></pre>
<p>This guarantees that Lean will favor other instances and fall back on
<code>propDecidable</code> only after other attempts to infer decidability have
failed.</p>
<p>The <code>Decidable</code> type class also provides a bit of small-scale
automation for proving theorems. The standard library introduces the
tactic <code>decide</code> that uses the <code>Decidable</code> instance to solve simple goals.</p>
<pre><code class="language-lean">example : 10 &lt; 5 ∨ 1 &gt; 0 := by
  decide

example : ¬ (True ∧ False) := by
  decide

example : 10 * 20 = 200 := by
  decide

theorem ex : True ∧ 2 = 1+1 := by
  decide

#print ex
-- theorem ex : True ∧ 2 = 1 + 1 :=
-- of_decide_eq_true (Eq.refl true)

#check @of_decide_eq_true
-- ∀ {p : Prop} [Decidable p], decide p = true → p

#check @decide
-- (p : Prop) → [Decidable p] → Bool
</code></pre>
<p>They work as follows. The expression <code>decide p</code> tries to infer a
decision procedure for <code>p</code>, and, if it is successful, evaluates to
either <code>true</code> or <code>false</code>. In particular, if <code>p</code> is a true closed
expression, <code>decide p</code> will reduce definitionally to the Boolean <code>true</code>.
On the assumption that <code>decide p = true</code> holds, <code>of_decide_eq_true</code>
produces a proof of <code>p</code>. The tactic <code>decide</code> puts it all together to
prove a target <code>p</code>. By the previous observations,
<code>decide</code> will succeed any time the inferred decision procedure
for <code>c</code> has enough information to evaluate, definitionally, to the <code>isTrue</code> case.</p>
<h2 id="managing-type-class-inference"><a class="header" href="#managing-type-class-inference">Managing Type Class Inference</a></h2>
<p>If you are ever in a situation where you need to supply an expression
that Lean can infer by type class inference, you can ask Lean to carry
out the inference using <code>inferInstance</code>:</p>
<pre><code class="language-lean">def foo : Add Nat := inferInstance
def bar : Inhabited (Nat → Nat) := inferInstance

#check @inferInstance
-- {α : Sort u} → [α] → α
</code></pre>
<p>In fact, you can use Lean's <code>(t : T)</code> notation to specify the class whose instance you are looking for,
in a concise manner:</p>
<pre><code class="language-lean">#check (inferInstance : Add Nat)
</code></pre>
<p>You can also use the auxiliary definition <code>inferInstanceAs</code>:</p>
<pre><code class="language-lean">#check inferInstanceAs (Add Nat)

#check @inferInstanceAs
-- (α : Sort u) → [α] → α
</code></pre>
<p>Sometimes Lean can't find an instance because the class is buried
under a definition. For example, Lean cannot
find an instance of <code>Inhabited (Set α)</code>. We can declare one
explicitly:</p>
<pre><code class="language-lean">def Set (α : Type u) := α → Prop

-- fails
-- example : Inhabited (Set α) :=
--  inferInstance

instance : Inhabited (Set α) :=
  inferInstanceAs (Inhabited (α → Prop))
</code></pre>
<p>At times, you may find that the type class inference fails to find an
expected instance, or, worse, falls into an infinite loop and times
out. To help debug in these situations, Lean enables you to request a
trace of the search:</p>
<pre><code class="language-lean">set_option trace.Meta.synthInstance true
</code></pre>
<p>If you are using VS Code, you can read the results by hovering over
the relevant theorem or definition, or opening the messages window
with <code>Ctrl-Shift-Enter</code>. In Emacs, you can use <code>C-c C-x</code> to run an
independent Lean process on your file, and the output buffer will show
a trace every time the type class resolution procedure is subsequently
triggered.</p>
<p>You can also limit the search using the following options:</p>
<pre><code class="language-lean">set_option synthInstance.maxHeartbeats 10000
set_option synthInstance.maxSize 400
</code></pre>
<p>Option <code>synthInstance.maxHeartbeats</code> specifies the maximum amount of
heartbeats per typeclass resolution problem. A heartbeat is the number of
(small) memory allocations (in thousands), 0 means there is no limit.
Option <code>synthInstance.maxSize</code> is the maximum number of instances used
to construct a solution in the type class instance synthesis procedure.</p>
<p>Remember also that in both the VS Code and Emacs editor modes, tab
completion works in <code>set_option</code>, to help you find suitable options.</p>
<p>As noted above, the type class instances in a given context represent
a Prolog-like program, which gives rise to a backtracking search. Both
the efficiency of the program and the solutions that are found can
depend on the order in which the system tries the instance. Instances
which are declared last are tried first. Moreover, if instances are
declared in other modules, the order in which they are tried depends
on the order in which namespaces are opened. Instances declared in
namespaces which are opened later are tried earlier.</p>
<p>You can change the order that type class instances are tried by
assigning them a <em>priority</em>. When an instance is declared, it is
assigned a default priority value. You can assign other priorities
when defining an instance. The following example illustrates how this
is done:</p>
<pre><code class="language-lean">class Foo where
  a : Nat
  b : Nat

instance (priority := default+1) i1 : Foo where
  a := 1
  b := 1

instance i2 : Foo where
  a := 2
  b := 2

example : Foo.a = 1 :=
  rfl

instance (priority := default+2) i3 : Foo where
  a := 3
  b := 3

example : Foo.a = 3 :=
  rfl
</code></pre>
<h2 id="coercions-using-type-classes"><a class="header" href="#coercions-using-type-classes">Coercions using Type Classes</a></h2>
<p>The most basic type of coercion maps elements of one type to another. For example, a coercion from <code>Nat</code> to <code>Int</code> allows us to view any element <code>n : Nat</code> as an element of <code>Int</code>. But some coercions depend on parameters; for example, for any type <code>α</code>, we can view any element <code>as : List α</code> as an element of <code>Set α</code>, namely, the set of elements occurring in the list. The corresponding coercion is defined on the &quot;family&quot; of types <code>List α</code>, parameterized by <code>α</code>.</p>
<p>Lean allows us to declare three kinds of coercions:</p>
<ul>
<li>from a family of types to another family of types</li>
<li>from a family of types to the class of sorts</li>
<li>from a family of types to the class of function types</li>
</ul>
<p>The first kind of coercion allows us to view any element of a member of the source family as an element of a corresponding member of the target family. The second kind of coercion allows us to view any element of a member of the source family as a type. The third kind of coercion allows us to view any element of the source family as a function. Let us consider each of these in turn.</p>
<p>In Lean, coercions are implemented on top of the type class resolution framework. We define a coercion from <code>α</code> to <code>β</code> by declaring an instance of <code>Coe α β</code>. For example, we can define a coercion from <code>Bool</code> to <code>Prop</code> as follows:</p>
<pre><code class="language-lean">instance : Coe Bool Prop where
  coe b := b = true
</code></pre>
<p>This enables us to use boolean terms in if-then-else expressions:</p>
<pre><code class="language-lean">#eval if true then 5 else 3
#eval if false then 5 else 3
</code></pre>
<p>We can define a coercion from <code>List α</code> to <code>Set α</code> as follows:</p>
<pre><code class="language-lean"><span class="boring">def Set (α : Type u) := α → Prop
</span><span class="boring">def Set.empty {α : Type u} : Set α := fun _ =&gt; False
</span><span class="boring">def Set.mem (a : α) (s : Set α) : Prop := s a
</span><span class="boring">def Set.singleton (a : α) : Set α := fun x =&gt; x = a
</span><span class="boring">def Set.union (a b : Set α) : Set α := fun x =&gt; a x ∨ b x
</span><span class="boring">notation &quot;{ &quot; a &quot; }&quot; =&gt; Set.singleton a
</span><span class="boring">infix:55 &quot; ∪ &quot; =&gt; Set.union
</span>def List.toSet : List α → Set α
  | []    =&gt; Set.empty
  | a::as =&gt; {a} ∪ as.toSet

instance : Coe (List α) (Set α) where
  coe a := a.toSet

def s : Set Nat := {1}
#check s ∪ [2, 3]
-- s ∪ List.toSet [2, 3] : Set Nat
</code></pre>
<p>We can use the notation <code>↑</code> to force a coercion to be introduced in a particular place. It is also helpful to make our intent clear, and work around limitations of the coercion resolution system.</p>
<pre><code class="language-lean"><span class="boring">def Set (α : Type u) := α → Prop
</span><span class="boring">def Set.empty {α : Type u} : Set α := fun _ =&gt; False
</span><span class="boring">def Set.mem (a : α) (s : Set α) : Prop := s a
</span><span class="boring">def Set.singleton (a : α) : Set α := fun x =&gt; x = a
</span><span class="boring">def Set.union (a b : Set α) : Set α := fun x =&gt; a x ∨ b x
</span><span class="boring">notation &quot;{ &quot; a &quot; }&quot; =&gt; Set.singleton a
</span><span class="boring">infix:55 &quot; ∪ &quot; =&gt; Set.union
</span><span class="boring">def List.toSet : List α → Set α
</span><span class="boring">  | []    =&gt; Set.empty
</span><span class="boring">  | a::as =&gt; {a} ∪ as.toSet
</span><span class="boring">instance : Coe (List α) (Set α) where
</span><span class="boring">  coe a := a.toSet
</span>def s : Set Nat := {1}

#check let x := ↑[2, 3]; s ∪ x
-- let x := List.toSet [2, 3]; s ∪ x : Set Nat
#check let x := [2, 3]; s ∪ x
-- let x := [2, 3]; s ∪ List.toSet x : Set Nat
</code></pre>
<p>Lean also supports dependent coercions using the type class <code>CoeDep</code>. For example, we cannot coerce arbitrary propositions to <code>Bool</code>, only the ones that implement the <code>Decidable</code> typeclass.</p>
<pre><code class="language-lean">instance (p : Prop) [Decidable p] : CoeDep Prop p Bool where
  coe := decide p
</code></pre>
<p>Lean will also chain (non-dependent) coercions as necessary. Actually, the type class <code>CoeT</code> is the transitive closure of <code>Coe</code>.</p>
<p>Let us now consider the second kind of coercion. By the <em>class of sorts</em>, we mean the collection of universes <code>Type u</code>. A coercion of the second kind is of the form:</p>
<pre><code>    c : (x1 : A1) → ... → (xn : An) → F x1 ... xn → Type u
</code></pre>
<p>where <code>F</code> is a family of types as above. This allows us to write <code>s : t</code> whenever <code>t</code> is of type <code>F a1 ... an</code>. In other words, the coercion allows us to view the elements of <code>F a1 ... an</code> as types. This is very useful when defining algebraic structures in which one component, the carrier of the structure, is a <code>Type</code>. For example, we can define a semigroup as follows:</p>
<pre><code class="language-lean">structure Semigroup where
  carrier : Type u
  mul : carrier → carrier → carrier
  mul_assoc (a b c : carrier) : mul (mul a b) c = mul a (mul b c)

instance (S : Semigroup) : Mul S.carrier where
  mul a b := S.mul a b
</code></pre>
<p>In other words, a semigroup consists of a type, <code>carrier</code>, and a multiplication, <code>mul</code>, with the property that the multiplication is associative. The <code>instance</code> command allows us to write <code>a * b</code> instead of <code>Semigroup.mul S a b</code> whenever we have <code>a b : S.carrier</code>; notice that Lean can infer the argument <code>S</code> from the types of <code>a</code> and <code>b</code>. The function <code>Semigroup.carrier</code> maps the class <code>Semigroup</code> to the sort <code>Type u</code>:</p>
<pre><code class="language-lean"><span class="boring">structure Semigroup where
</span><span class="boring">  carrier : Type u
</span><span class="boring">  mul : carrier → carrier → carrier
</span><span class="boring">  mul_assoc (a b c : carrier) : mul (mul a b) c = mul a (mul b c)
</span><span class="boring">instance (S : Semigroup) : Mul S.carrier where
</span><span class="boring">  mul a b := S.mul a b
</span>#check Semigroup.carrier
</code></pre>
<p>If we declare this function to be a coercion, then whenever we have a semigroup <code>S : Semigroup</code>, we can write <code>a : S</code> instead of <code>a : S.carrier</code>:</p>
<pre><code class="language-lean"><span class="boring">structure Semigroup where
</span><span class="boring">  carrier : Type u
</span><span class="boring">  mul : carrier → carrier → carrier
</span><span class="boring">  mul_assoc (a b c : carrier) : mul (mul a b) c = mul a (mul b c)
</span><span class="boring">instance (S : Semigroup) : Mul S.carrier where
</span><span class="boring">  mul a b := S.mul a b
</span>instance : CoeSort Semigroup (Type u) where
  coe s := s.carrier

example (S : Semigroup) (a b c : S) : (a * b) * c = a * (b * c) :=
  Semigroup.mul_assoc _ a b c
</code></pre>
<p>It is the coercion that makes it possible to write <code>(a b c : S)</code>. Note that, we define an instance of <code>CoeSort Semigroup (Type u)</code> instead of <code>Coe Semigroup (Type u)</code>.</p>
<p>By the <em>class of function types</em>, we mean the collection of Pi types <code>(z : B) → C</code>. The third kind of coercion has the form:</p>
<pre><code>    c : (x1 : A1) → ... → (xn : An) → (y : F x1 ... xn) → (z : B) → C
</code></pre>
<p>where <code>F</code> is again a family of types and <code>B</code> and <code>C</code> can depend on <code>x1, ..., xn, y</code>. This makes it possible to write <code>t s</code> whenever <code>t</code> is an element of <code>F a1 ... an</code>. In other words, the coercion enables us to view elements of <code>F a1 ... an</code> as functions. Continuing the example above, we can define the notion of a morphism between semigroups <code>S1</code> and <code>S2</code>. That is, a function from the carrier of <code>S1</code> to the carrier of <code>S2</code> (note the implicit coercion) that respects the multiplication. The projection <code>morphism.mor</code> takes a morphism to the underlying function:</p>
<pre><code class="language-lean"><span class="boring">structure Semigroup where
</span><span class="boring">  carrier : Type u
</span><span class="boring">  mul : carrier → carrier → carrier
</span><span class="boring">  mul_assoc (a b c : carrier) : mul (mul a b) c = mul a (mul b c)
</span><span class="boring">instance (S : Semigroup) : Mul S.carrier where
</span><span class="boring">  mul a b := S.mul a b
</span><span class="boring">instance : CoeSort Semigroup (Type u) where
</span><span class="boring">  coe s := s.carrier
</span>structure Morphism (S1 S2 : Semigroup) where
  mor : S1 → S2
  resp_mul : ∀ a b : S1, mor (a * b) = (mor a) * (mor b)

#check @Morphism.mor
</code></pre>
<p>As a result, it is a prime candidate for the third type of coercion.</p>
<pre><code class="language-lean"><span class="boring">structure Semigroup where
</span><span class="boring">  carrier : Type u
</span><span class="boring">  mul : carrier → carrier → carrier
</span><span class="boring">  mul_assoc (a b c : carrier) : mul (mul a b) c = mul a (mul b c)
</span><span class="boring">instance (S : Semigroup) : Mul S.carrier where
</span><span class="boring">  mul a b := S.mul a b
</span><span class="boring">instance : CoeSort Semigroup (Type u) where
</span><span class="boring">  coe s := s.carrier
</span><span class="boring">structure Morphism (S1 S2 : Semigroup) where
</span><span class="boring">  mor : S1 → S2
</span><span class="boring">  resp_mul : ∀ a b : S1, mor (a * b) = (mor a) * (mor b)
</span>instance (S1 S2 : Semigroup) : CoeFun (Morphism S1 S2) (fun _ =&gt; S1 → S2) where
  coe m := m.mor

theorem resp_mul {S1 S2 : Semigroup} (f : Morphism S1 S2) (a b : S1)
        : f (a * b) = f a * f b :=
  f.resp_mul a b

example (S1 S2 : Semigroup) (f : Morphism S1 S2) (a : S1) :
      f (a * a * a) = f a * f a * f a :=
  calc f (a * a * a)
    _ = f (a * a) * f a := by rw [resp_mul f]
    _ = f a * f a * f a := by rw [resp_mul f]
</code></pre>
<p>With the coercion in place, we can write <code>f (a * a * a)</code> instead of <code>f.mor (a * a * a)</code>. When the <code>Morphism</code>, <code>f</code>, is used where a function is expected, Lean inserts the coercion. Similar to <code>CoeSort</code>, we have yet another class <code>CoeFun</code> for this class of coercions. The field <code>F</code> is used to specify the function type we are coercing to. This type may depend on the type we are coercing from.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="structures_and_records.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="conv.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="structures_and_records.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="conv.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->


    </body>
</html>
